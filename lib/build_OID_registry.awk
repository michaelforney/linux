# SPDX-License-Identifier: GPL-2.0-or-later
#
# Build a static ASN.1 Object Identified (OID) registry
#
# Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.
# Based on perl script written by David Howells (dhowells@redhat.com)

function bit(n, i) {
	return n % 2 ^ (i + 1) > 2 ^ i - 1
}

#
# Read OID lines and determine the lengths of the encoded data arrays.
#
/[ \t]+OID_[a-zA-Z][a-zA-Z0-9_]+,[ \t]+\/\*[ \t]+[012][.0-9]*[ \t]+\*\// {
	++num_oids

	names[num_oids] = substr($1, 5, length($1) - 5)
	oids[num_oids] = $3
	indices[num_oids] = total_length
	sorted[num_oids] = num_oids

	# Encode the OID
	n = 1
	num_components = split($3, components, ".")
	octets[num_oids, n] = components[1] * 40 + components[2]
	for (i = 3; i <= num_components; ++i) {
		c = components[i]

		# Base128 encode the number
		n += 1 + (c == 0 ? 0 : int(log(c) / log(2) / 7))
		octets[num_oids, n] = c % 128
		for (j = n - 1; c > 128; --j) {
			c = int(c / 128)
			octets[num_oids, j] = c % 128 + 128
		}
	}
	total_length += n

	# Calculate the hash
	h = n - 1
	for (i = 1; i <= n; ++i)
		h += octets[num_oids, i] * 33
	hash = 0
	for (i = 7; i >= 0; --i)
		hash = hash * 2 + (((bit(h, i) != bit(h, i + 8)) != bit(h, i + 16)) != bit(h, i + 24))

	num_octets[num_oids] = n
	hashes[num_oids] = hash
}

function isless(i, j) {
	if (hashes[i] != hashes[j])
		return hashes[i] < hashes[j]
	if (num_octets[i] != num_octets[j])
		return num_octets[i] < num_octets[j]
	for (k = num_octets[i]; k > 0; --k) {
		if (octets[i, k] != octets[j, k])
			return octets[i, k] < octets[j, k]
	}
	return 0
}

function sort(lo, hi) {
	if (lo >= hi)
		return
	pivot = sorted[hi]
	i = lo
	for (j = lo; j <= hi; ++j) {
		if (!isless(sorted[j], pivot))
			continue
		tmp = sorted[i]
		sorted[i] = sorted[j]
		sorted[j] = tmp
		++i
	}
	tmp = sorted[i]
	sorted[i] = sorted[hi]
	sorted[hi] = tmp
	sort(lo, i - 1)
	sort(i + 1, hi)
}

END {
	#
	# Emit the look-up-by-OID index table
	#
	printf "/*\n * Automatically generated by lib/build_OID_registry.awk.  Do not edit\n */\n\n"
	printf "static const unsigned %s oid_index[OID__NR + 1] = {\n", (total_length <= 255) ? "char" : "short"
	for (i = 1; i <= num_oids; ++i)
		printf "\t[OID_%s] = %u,\n", names[i], indices[i]
	printf "\t[OID__NR] = %u\n};\n\n", total_length

	#
	# Emit the OID data
	#
	printf "static const unsigned char oid_data[%u] = {\n", total_length
	for (i = 1; i <= num_oids; ++i) {
		printf "\t"
		for (j = 1; j <= num_octets[i]; ++j)
			printf "%u, ", octets[i, j]
		printf "\t// %s\n", names[i]
	}
	printf "};\n\n"

	#
	# Emit the search index and hash value table
	#
	sort(1, num_oids)
	printf "static const struct {\n"
	printf "\tunsigned char hash;\n"
	printf "\tenum OID oid : %u;\n", (num_oids <= 256) ? 8 : 16
	printf "} oid_search_table[OID__NR] = {\n"
	for (i = 1; i <= num_oids; ++i) {
		j = sorted[i]
		printf "\t[%3u] = { %3u, OID_%-35s }, // ", i - 1, hashes[j], names[j]
		for (k = 1; k <= num_octets[j]; ++k)
			printf "%02x", octets[j, k]
		printf "\n"
	}
	printf "};\n"
}
